#include "Global.h"
#include <GMLIB/Files/JsonFile.h>
#include <GMLIB/Files/Language/McLang.h>
#include <GMLIB/Files/Language/ResourceLanguage.h>
#include <GMLIB/Mod/Addons/CustomPacks.h>

namespace GMLIB::Files {

std::string defaultManifest = R"({
    "format_version": 2,
    "header": {
        "description": "Plugin language pack, this pack is automatically generated by GMLIB.",
        "platform_locked" : false,
        "min_engine_version": [1, 20, 60]
    },
    "modules": [
        {
            "description": "Plugin language pack, this pack is automatically generated by GMLIB.",
            "type": "resources"
        }
    ]
})";

ResourceLanguage::ResourceLanguage(
    std::string directoryPath,
    std::string pluginName,
    ushort      versionMajor,
    ushort      versionMinor,
    ushort      versionPatch
)
: mPath(directoryPath),
  mPluginName(pluginName) {
    mLanguages = {};
    mVersion   = Version(versionMajor, versionMinor, versionPatch, "", "");
}

bool buildManisest(Version& version, std::string path, std::string name) {
    if (std::filesystem::exists(path)) {
        std::ifstream inputFile(path);
        std::string   fileContent((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());
        auto          oldJson    = nlohmann::ordered_json::parse(fileContent, nullptr, true, true);
        auto          oldVersion = oldJson["header"]["version"].get<std::vector<int>>();
        if (oldVersion[0] == version.getMajor() && oldVersion[1] == version.getMinor()
            && oldVersion[2] == version.getPatch()) {
            return false;
        }
    }
    std::vector<int> ver          = {version.getMajor(), version.getMinor(), version.getPatch()};
    auto             json         = nlohmann::json::parse(defaultManifest, nullptr, true, true);
    json["header"]["uuid"]        = mce::UUID::random();
    json["header"]["version"]     = ver;
    json["header"]["name"]        = name + " Language Pack";
    json["modules"][0]["uuid"]    = mce::UUID::random();
    json["modules"][0]["version"] = ver;
    std::ofstream manifestFile(path);
    manifestFile << json.dump(4);
    manifestFile.close();
    return true;
}

void ResourceLanguage::initLanguage() {
    Mod::CustomPacks::addCustomPackPath(mPath);
    auto path = mPath;
    if (!path.ends_with("/")) {
        path = path + "/";
    }
    std::filesystem::create_directories(path + "language_pack");
    std::string pathLangDir  = "language_pack/texts/";
    std::string pathManifest = "language_pack/manifest.json";
    buildManisest(mVersion, path + pathManifest, mPluginName);
    std::filesystem::create_directories(path + pathLangDir);
    auto langJson = nlohmann::json::array();
    for (auto& lang : mLanguages) {
        langJson.push_back(lang.first);
        auto langPath    = path + pathLangDir + lang.first + ".lang";
        auto newLangData = McLang::parse(lang.second);
        if (std::filesystem::exists(langPath)) {
            auto oldLangData = McLang::parse_file(langPath);
            newLangData.merge_patch(oldLangData);
        }
        newLangData.write_to_file(langPath);
    }
    if (std::filesystem::exists(path + pathLangDir + "languages.json")) {
        auto readPath    = path + pathLangDir + "languages.json";
        auto oldData     = GMLIB::Files::JsonFile::readFromFile(readPath);
        auto oldLangKeys = oldData.get<std::vector<std::string>>();
        for (auto& lk : oldLangKeys) {
            if (!mLanguages.count(lk)) {
                langJson.push_back(lk);
            }
        }
    }
    std::ofstream newLangJson(path + pathLangDir + "languages.json");
    newLangJson << langJson.dump(4);
    newLangJson.close();
}

void ResourceLanguage::addLanguage(std::string identifider, std::string& language) {
    mLanguages[identifider] = language;
}

void ResourceLanguage::addLanguages(std::vector<std::pair<std::string, std::string>>& languages) {
    for (auto& data : languages) {
        mLanguages[data.first] = data.second;
    }
}

} // namespace GMLIB::Files